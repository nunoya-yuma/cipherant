# Cipherant 開発ガイド

## プロジェクト概要
Rust製のLLMを活用したパーソナルリサーチエージェント。ウェブ、ローカルファイル、PDFなど複数の情報源から情報を収集・統合し、ユーザーの文脈に合わせた応答を生成する。完全ローカルでの実装を優先し、プライバシー保護と高性能を重視する。

## コーディング規約

### 命名規則
- Rustの標準的な命名規則に従う
  - 型名、トレイト名: `PascalCase`
  - 関数名、変数名: `snake_case`
  - 定数: `SCREAMING_SNAKE_CASE`
  - モジュール名: `snake_case`

### 設計原則
- **エラー処理を徹底する**: `Result`型を適切に使用し、`unwrap()`は避ける
- **並行処理では安全性を最優先**: データ競合を防ぐため、所有権とライフタイムを意識
- **依存関係は最小限に抑える**: 必要なクレートのみを追加
- **各モジュールは単一責任の原則に従う**: 1つのモジュールは1つの明確な役割を持つ
- **ドキュメンテーションコメントを充実させる**: 公開APIには必ず`///`コメントを記述

### コードスタイル
- `rustfmt`でフォーマット: `cargo fmt`
- `clippy`でリント: `cargo clippy`
- コメントやドキュメントは日本語でも英語でも可（コードは英語）

## 開発フロー

### 基本的な流れ
1. まずプロジェクト構造とベース機能を実装
2. 小さな単位で動作確認しながら進める
3. 各モジュールはユニットテストを書く
4. 新機能追加前に設計レビューを行う

### ブランチ戦略
- `main`ブランチで直接作業しない
- 機能ごとに新しいブランチを作成: `feature/cli-base`, `feature/web-scraper` など
- 作業完了後はプルリクエストを作成してマージ

### コミット戦略
- 小さく頻繁にコミット
- 1つの機能変更、1つのバグ修正ごとにコミット
- 各コミットは独立して動作する状態を保つ
- テスト通過やビルド成功の節目で必ずコミット

## 優先実装事項

### フェーズ1: 基盤実装
1. 基本的なCLI構造（`clap`を使用）
2. プロジェクトのモジュール分割
3. 設定ファイルの読み込み機能
4. 基本的なエラー型の定義

### フェーズ2: 情報収集機能
1. シンプルなウェブスクレイピング（`reqwest`, `scraper`）
2. ローカルファイル検索
3. 結果のJSON保存

### フェーズ3: LLM統合
1. LLMインテグレーション（まず1つのバックエンド）
2. プロンプトテンプレート管理
3. 基本的な会話処理

### フェーズ4: 高度な機能
1. ベクトルDB統合（セマンティック検索）
2. PDF処理
3. 並列処理の最適化

## ビルドとテスト

### 開発時
```bash
# ビルドと実行
cargo run -- ${url}
## e.g.)
cargo run -- https://example.com

# フォーマット
cargo fmt

# リント
cargo clippy

# テスト実行
cargo test
```

### リリースビルド
```bash
cargo build --release
```

## 参考リソース
- アーキテクチャ設計: [design.md](./design.md)
- Rust公式ドキュメント: https://doc.rust-lang.org/
- The Rust Book (日本語): https://doc.rust-jp.rs/book-ja/
